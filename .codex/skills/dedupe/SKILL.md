# $dedupe

目的:

- 既存実装の見落としによる「同じような関数/型/スキーマ/ユーティリティの増殖」を防ぐ。
- 追加前に ripgrep (`rg`) で横断検索し、追記/統合を優先する。

前提:

- `rg` が利用できること（`rg --version`）。
- リポジトリ root で実行する。

入力:

- 追加しようとしている「概念名」「関数名」「型名」「スキーマ名」「コンポーネント名」などのキーワード。
- 迷う場合は 2〜3 個に絞る（例: `Invoice`, `invoice`, `Billing` のような言い換えは増やさず、既存で使われている語を優先）。

手順:

1. 追加前の探索（必須）

- まず “完全一致に近い” 文字列で探す（型名/関数名/コンポーネント名は大小区別が効くのでそのまま入れる）。
  - まず全体検索:
    - `rg -n "Keyword" .`

  - TypeScript/TSXに絞る:
    - `rg -n -S "Keyword" -g'*.ts' -g'*.tsx'`

  - Pythonに絞る:
    - `rg -n -S "keyword" -g'*.py'`

  - 既存の export / 型 / interface を探すヒント:
    - `rg -n -S "export (type|interface|class|function) Keyword" -g'*.ts' -g'*.tsx'`
    - `rg -n -S "type Keyword\\b|interface Keyword\\b|class Keyword\\b|function Keyword\\b" -g'*.ts' -g'*.tsx'`

  - Zodスキーマ想定のヒント:
    - `rg -n -S "KeywordSchema\\b" -g'*.ts' -g'*.tsx'`
    - `rg -n -S "z\\.object\\(" -g'*.ts' -g'*.tsx'`

- ファイル名も探す（`rg` は中身検索なので別途）:
  - `find . -type f -iname '*keyword*'`

2. 結果の分類（方針決定）

- 既に同等機能がある:
  - 新規作成しない。既存を拡張（追記）する。
  - 呼び出し側を既存へ寄せる（統合）。

- 近いが少し違うものがある:
  - “命名を揃えて統合できるか” を優先検討する。
  - 統合できない場合は、責務の境界を明確化し、名前で区別できるようにする（例: `parseXxx` と `formatXxx` のように役割で分ける）。

- 何も見つからない:
  - 新規作成してよいが、命名規則（AGENTS.md）に従い、検索で再発見できる名前にする。

3. 新規作成時のチェックリスト（必須）

- 名前:
  - 既存コードで使われている語彙を踏襲する（言い換えを作らない）。
  - 主要な export 名とファイル名を対応させる（探しやすくする）。

- 配置:
  - 既存の配置規約に従う（例: 共通utilは `lib/`、UIは `components/`、backendは `backend/` 配下）。
  - `fix/` `tmp/` `backup/` のような退避ディレクトリを作らない。

- 参照更新:
  - 既存の重複候補があるなら、呼び出し側を更新して置き換える（片方を放置しない）。

4. 実装後の検証（必須）

- 変更規模に応じて:
  - 速い検証: `$verify-fast`
  - PR前/完了前: `$verify-full`

完了条件:

- 既存探索の証跡（どのキーワードで探したか）が説明できる。
- 重複を増やさずに要件を満たした。
- 検証コマンドが成功している。
